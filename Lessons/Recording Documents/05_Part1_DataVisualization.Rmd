---
title: "5: Part 1 - Data Visualization Basics"
author: "Environmental Data Analytics | John Fay and Luana Lima | Developed by Kateri Salk"
date: "Spring 2024"
output: pdf_document
geometry: margin=2.54cm
editor_options: 
  chunk_output_type: console
---

## Objectives
1. Perform simple data visualizations in the R package `ggplot`
2. Develop skills to adjust aesthetics and layers in graphs
3. Apply a decision tree framework for appropriate graphing methods

## Opening discussion
Effective data visualization depends on purposeful choices about graph types. The ideal graph type depends on the type of data and the message the visualizer desires to communicate. The best visualizations are clear and simple. A good resource for data visualization is [Data to Viz](https://www.data-to-viz.com/), which includes both a decision tree for visualization types and explanation pages for each type of data, including links to R resources to create them. Take a few minutes to explore this website.

## Set Up

```{r, message = FALSE, warning = FALSE}
library(tidyverse);library(lubridate);library(here)
#install.packages("ggridges")
library(ggridges)

here()

PeterPaul.chem.nutrients <- 
  read.csv(here("Data/Processed/NTL-LTER_Lake_Chemistry_Nutrients_PeterPaul_Processed.csv"), stringsAsFactors = TRUE)
PeterPaul.chem.nutrients.gathered <-
  read.csv(here("Data/Processed/NTL-LTER_Lake_Nutrients_PeterPaulGathered_Processed.csv"), stringsAsFactors = TRUE)
EPAair <- read.csv(here("Data/Processed/EPAair_O3_PM25_NC1819_Processed.csv"), stringsAsFactors = TRUE)

EPAair$Date <- as.Date(EPAair$Date, format = "%Y-%m-%d")
PeterPaul.chem.nutrients$sampledate <- as.Date(PeterPaul.chem.nutrients$sampledate, format = "%Y-%m-%d")
PeterPaul.chem.nutrients.gathered$sampledate <- as.Date(PeterPaul.chem.nutrients.gathered$sampledate, format = "%Y-%m-%d")

```

## ggplot

ggplot, called from the package `ggplot2`, is a graphing and image generation tool in R. This package is part of tidyverse. While base R has graphing capabilities, ggplot has the capacity for a wider range and more sophisticated options for graphing. 
ggplot has only a few rules: 

* The first line of ggplot code always starts with `ggplot()`
* A data frame must be specified within the `ggplot()` function. Additional datasets can be specified in subsequent layers.
* Aesthetics must be specified, most commonly x and y variables but including others. Aesthetics can be specified in the `ggplot()` function or in subsequent layers.
* Additional layers must be specified to fill the plot. 

### Geoms

Here are some commonly used layers for plotting in ggplot: 

* geom_bar
* geom_histogram
* geom_freqpoly
* geom_boxplot
* geom_violin
* geom_dotplot
* geom_density_ridges
* geom_point
* geom_errorbar
* geom_smooth
* geom_line
* geom_area
* geom_abline (plus geom_hline and geom_vline)
* geom_text

### Aesthetics
Here are some commonly used aesthetic types that can be manipulated in ggplot: 

* color
* fill
* shape
* size
* transparency

### Plotting continuous variables over time: Scatterplot and Line Plot

```{r, fig.height = 3, fig.width = 4, warning = FALSE}
# Scatterplot
ggplot(EPAair, aes(x = Date, y = Ozone)) + 
  geom_point()

O3plot <- ggplot(EPAair) +
  geom_point(aes(x = Date, y = Ozone))
print(O3plot)

# Fix this code
O3plot2 <- ggplot(EPAair) +
  #geom_point(aes(x = Date, y = Ozone, color = "blue")) This can not give a figure with all blue dots cuz it is just adding another layer with a "blue" variable. Since "blue" is not a variable within the dataset, it doesn't need to be placed within aes().
  geom_point(aes(x = Date, y = Ozone), color = "blue")
print(O3plot2)

# Add additional variables
# How could you automatically assign a marker color to a variable? 
PMplot <- 
  ggplot(EPAair) +
  geom_point(aes(x = Month, y = PM2.5, shape = as.factor(Year), color = Site.Name))
print(PMplot)
#Why to use "as.factor(Year)" ? The reason for using as.factor(Year) in aes(shape = as.factor(Year)) is to treat the variable Year as a categorical variable, which allows each unique year in the dataset to be represented by a different shape in the plot. By converting Year to a factor, ggplot understands that it should treat it as a categorical variable rather than a continuous one. This helps in visually distinguishing data points belonging to different years more effectively.

#Can I change the X axis to show each month like 1, 2, ..., 12?
ggplot(EPAair) +
  geom_point(aes(x = Month, y = PM2.5, shape = as.factor(Year), color = Site.Name)) +
  scale_x_continuous( #a function in ggplot2 (a popular R package for data visualization) that allows you to customize the continuous scale of the x-axis in your plot.
    breaks = 1:12, # This specifies the positions (ticks) where you want to place the breaks on the x-axis. Here, it sets breaks at each month from 1 to 12.
    labels = month.abb[1:12]) #a built-in R variable containing the abbreviations for the months. month.abb[1:12] extracts the three-letter abbreviation for each month from January to December.

# Separate plot with facets
PMplot.faceted <-
  ggplot(EPAair, aes(x = Month, y = PM2.5, shape = as.factor(Year))) +
  geom_point() +
  facet_wrap(vars(Site.Name),  #vars() is a function in ggplot2 that is used to quote or select variables. When used within facet_wrap(), vars(Site.Name) tells ggplot2 to create facets based on the levels of the variable Site.Name. Essentially, it's specifying the variable by which you want to create separate plots.
             nrow = 3) # nrow is an argument within facet_wrap() that determines the number of rows of facets to arrange on the plot. In this case, nrow = 3 specifies that the facets should be arranged in three rows. This means that if there are more than three levels of the Site.Name variable, the facets will be arranged in multiple rows to accommodate them.
print(PMplot.faceted)

# Filter dataset within plot building and facet by multiple variables
PMplot.faceted2 <- 
  ggplot(subset(EPAair, Site.Name == "Clemmons Middle" | Site.Name == "Leggett" |
                  Site.Name == "Bryson City"), 
         aes(x = Month, y = PM2.5)) + 
  geom_point() +
  facet_grid(Site.Name ~ Year)  #Two big year groups and three site groups
print(PMplot.faceted2)

# Plot true time series with geom_line
PMplot.line <- 
  ggplot(subset(EPAair, Site.Name == "Leggett"), 
         aes(x = Date, y = PM2.5)) +
  geom_line()
print(PMplot.line)

```


### Plotting the relationship between two continuous variables: Scatterplot

```{r, fig.height = 3, fig.width = 4, warning = FALSE}
# Scatterplot
lightvsDO <- 
  ggplot(PeterPaul.chem.nutrients) +
  geom_point(aes(x = irradianceWater, y = dissolvedOxygen))
print(lightvsDO)

# Adjust axes
lightvsDOfixed <- 
  ggplot(PeterPaul.chem.nutrients) +
  geom_point(aes(x = irradianceWater, y = dissolvedOxygen)) +
  xlim(0, 250) + #This sets the limits of the x-axis. The x-axis will range from 0 to 250. Any data points with x-values outside this range will not be plotted.
  ylim(0, 20)
print(lightvsDOfixed)

# Depth in the fields of limnology and oceanography is on a reverse scale
tempvsdepth <- 
  ggplot(PeterPaul.chem.nutrients, aes(x = temperature_C, y = depth)) +
  #ggplot(PeterPaul.chem.nutrients, aes(x = temperature_C, y = depth, color = daynum)) +
  geom_point() +
  scale_y_reverse() # It reverses the direction of the y-axis, so that the shallow depths are at the top and the deeper depths are at the bottom, aligning with the convention typically used in fields like limnology and oceanography.
print(tempvsdepth)

NvsP <-
  ggplot(PeterPaul.chem.nutrients, aes(x = tp_ug, y = tn_ug, color = depth)) +
  geom_point() + # Adds points to the plot representing the individual data points. Each point corresponds to a combination of phosphorus and nitrogen concentrations, with its color indicating the depth.
  geom_smooth(method = lm) + #Fits a linear regression line to the data. This argument specifies that a linear model should be used to fit the line. This line represents the overall trend between phosphorus and nitrogen concentrations.
  geom_abline(aes(slope = 16, intercept = 0)) # Adds an abline (a straight line) to the plot with a fixed slope of 16 and intercept of 0. This line provides a reference or comparison to the regression line. The slope here is just a set value without precisely calculation.
print(NvsP)

# How to obtain the precise numerical values of the slope and other regression parameters:
# Fit linear regression model
lm_model <- lm(tn_ug ~ tp_ug, data = PeterPaul.chem.nutrients)
# Print summary of the model
summary(lm_model)

# The following code wont work!
NvsP2 <-
  ggplot(PeterPaul.chem.nutrients) +
  geom_point(aes(x = tp_ug, y = tn_ug, color = depth)) + 
  geom_smooth(method = lm) + 
print(NvsP2)
# Reason: The error message indicates that there is an issue with the geom_smooth() layer because it requires the aesthetics x and y to be explicitly specified. However, in the ggplot() call above, you only specify the dataset and don't provide the aes() function for the geom_smooth() layer.
# Why in other conditions, the aes argument can be put in geom_point call? What's the difference?
# Reason: 
# Mapping aesthetics in ggplot():When you specify aesthetics in the ggplot() function, those aesthetics are inherited by all subsequent geometric layers unless overridden. This approach is useful when you want the same aesthetic mappings to apply to multiple layers in your plot. It helps to keep your code concise and avoids repetition if the same aesthetic mappings are used across multiple layers.
# Mapping aesthetics in individual geometric layers: You can also specify aesthetics within individual geometric layers (geom_point(), geom_line(), etc.). This approach allows you to customize aesthetics for specific layers independently of others. It's useful when you want different aesthetic mappings for different layers, or when you want to override the mappings specified in ggplot(). It provides flexibility and granularity in customizing the appearance of your plot.
```

### Plotting continuous vs. categorical variables
A traditional way to display summary statistics of continuous variables is a bar plot with error bars. Let's explore why this might not be the most effective way to display this type of data. Navigate to the Caveats page on Data to Viz (https://www.data-to-viz.com/caveats.html) and find the page that explores barplots and error bars. 

What might be more effective ways to display the information? Navigate to the boxplots page in the Caveats section to explore further.

```{r, fig.height = 3, fig.width = 4, warning = FALSE}
# Box and whiskers plot
Nutrientplot3 <-
  ggplot(PeterPaul.chem.nutrients.gathered, aes(x = lakename, y = concentration)) +
  #geom_boxplot(aes(color = nutrient)) # Why didn't we use "fill"? Fill will color the box while not give dots colors.
print(Nutrientplot3)

# Dot plot
Nutrientplot4 <-
  ggplot(PeterPaul.chem.nutrients.gathered, aes(x = lakename, y = concentration)) +
  geom_dotplot(aes(color = nutrient, 
                   fill = nutrient), # This maps the variable nutrient to the fill aesthetic, meaning each dot will be filled with color according to the value of the nutrient variable. When using geom_dotplot(), the dots themselves are not filled or hollow. Unlike other geometric layers like geom_point(), geom_dotplot() doesn't inherently have the concept of a "fill" aesthetic for the dots themselves.
               binaxis = "y",  # Indicates that the binning should be along the y-axis (concentration).
               binwidth = 1,  # Specifies the width of each bin (in this case, 1 unit along the y-axis).
               stackdir = "center",  # Determines the direction in which the dots are stacked when they overlap. In this case, they are stacked toward the center.
               position = "dodge",  # Specifies that the dots should be dodged (positioned side by side) rather than stacked directly on top of each other.
               dotsize = 2) 
print(Nutrientplot4)

# Violin plot
Nutrientplot5 <-
  ggplot(PeterPaul.chem.nutrients.gathered, aes(x = lakename, y = concentration)) +
  geom_violin(aes(color = nutrient)) #
print(Nutrientplot5)

# Frequency polygons
# Using a tidy dataset
Nutrientplot6 <-
  ggplot(PeterPaul.chem.nutrients) +
  geom_freqpoly(aes(x = tn_ug), color = "darkred") +
  geom_freqpoly(aes(x = tp_ug), color = "darkblue") +
  geom_freqpoly(aes(x = nh34), color = "blue") +
  geom_freqpoly(aes(x = no23), color = "royalblue") +
  geom_freqpoly(aes(x = po4), color = "red") 
print(Nutrientplot6)
# Disadvantages of this argument: 1) There is no legend. 2) Repetition of geom_freqpoly for different nutrients.

# Using a gathered dataset
Nutrientplot7 <-   
  ggplot(PeterPaul.chem.nutrients.gathered) +
  geom_freqpoly(aes(x = concentration, color = nutrient))
print(Nutrientplot7)

# Frequency polygons have the risk of becoming spaghetti plots. 
# See <https://www.data-to-viz.com/caveat/spaghetti.html> for more info.

# Ridgeline plot
Nutrientplot6 <-
  ggplot(PeterPaul.chem.nutrients.gathered, aes(y = nutrient, x = concentration)) +
  geom_density_ridges(aes(fill = lakename), 
                      alpha = 0.5) #This sets the transparency of the density ridges to 50%, making them partially transparent. This helps to visualize overlapping ridges more easily.
print(Nutrientplot6)
#Ridgeline plots are especially useful when you have multiple distributions to compare, as they provide a clear visualization of the shape, spread, and overlap of the distributions.
#Interpretation: Areas where the ridges are wider indicate higher density of values for the corresponding category. Overlapping ridges suggest similar distributions of the continuous variable across different categories.

```
